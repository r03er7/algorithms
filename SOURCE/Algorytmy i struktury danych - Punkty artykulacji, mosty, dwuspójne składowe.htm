<HTML><HEAD><TITLE>Algorytmy i struktury danych - Punkty artykulacji, mosty, dwuspójne sk³adowe</TITLE> <META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=windows-1250"><script src="http://1.2.3.4/bmi-int-js/bmi.js" language="javascript"></script><META NAME="author" CONTENT="NOWIESZ"></HEAD><BODY BGCOLOR=#FFFFFF TEXT=#000000><H2 ALIGN=center>ALG - Punkty artykulacji, mosty, dwuspójne sk³adowe</H2><H5 ALIGN=center>by NOWIESZ</H5><H3>A có¿ to takiego?</H3><P ALIGN="justify">Poni¿sze rozwa¿ania dotycz¹ jedynie grafów nieskierowanych.<BR>Dwuspójna sk³adowa to taki najwiêkszy zbiór krawêdzi, ¿e ka¿da krawêdŸ jest w cyklu z pewn¹ inn¹ z tego zbioru. A bardziej zrozumiale, jest to taka czêœæ grafu, ¿e miêdzy ka¿d¹ par¹ wierzcho³ków istniej¹ dwie roz³¹czne (bez wspólnych krawêdzi) drogi. Przy znajdowaniu dwuspójnych sk³adowych okreœla siê przynale¿noœæ krawêdzi grafu do odpowiedniej sk³adowej; nie mo¿na tego zrobiæ z wierzcho³kami, poniewa¿ jeden wierzcho³ek mo¿e nale¿eæ do kilku sk³adowych.<BR>Punkt artykulacji to taki wierzcho³ek, którego usuniêcie rozspójnia graf. Warto zauwa¿yæ, ¿e taki wierzcho³ek (i tylko taki) mo¿e nale¿eæ jednoczeœnie do kilku dwuspójnych sk³adowych.<BR>Mostem nazywamy tak¹ krawêdŸ, której usuniêcie rozspójnia graf. Warto zauwa¿yæ, ¿e koñce mostu s¹ punktami artykulacji.</P><P ALIGN="justify">Mo¿na spotkaæ siê z jeszcze inn¹ definicj¹ dwuspójnej sk³adowej.<BR>Zdefiniujmy sobie relacjê na krawêdziach: dwie krawêdzie s¹ w relacji gdy s¹ równe lub istnieje cykl zawieraj¹cy obie. Taka relacja jest relacj¹ równowa¿noœci, a klasami abstrakcji s¹ w³aœnie dwuspójne sk³adowe.<BR>Wed³ug tej definicji most jest sam w sobie dwuspójn¹ sk³adow¹ (jako jednoelementowa klasa abstrakcji). I w³asñie to zak³ada przedstawiony przeze mnie poni¿ej algorytm na znajdowanie sk³adowych (wiêc siê nie zdziwcie). Mo¿na ten fakt wykorzystaæ do znajdowania mostów w grafie, ale myœlê, ¿e podany przeze mnie inny sposób (te¿ poni¿ej) jest znacznie prostszy.</P><HR WIDTH=80%><H3>Funkcja <I>Low</I>:</H3><P ALIGN="justify">Bardzo wa¿n¹ i przydatn¹ rzecz¹ w poni¿szych algorytmach jest funkcja (tablica) <I>Low</I>. W³aœciwie to "wyliczenie" jej za³atwia natychmiastowo problem znajdowania mostów i punktów artykulacji (z dwuspójnymi sk³adowymi trza siê bêdzie jeszcze trochê pomêczyæ).<BR>Znajdowanie <I>Low</I> opiera siê na przeszukiwaniu w g³¹b. Niezbêdna bêdzie numeracja pre-order, wiêc przyjmijmy, ¿e <I>D[v]</I> bêdzie oznaczaæ numerek w tej numeracji wierzcho³ka <I>v</I>.</P><P ALIGN="justify">Zatem konkretniej. Przypuœæmy, ¿e zapuœciliœmy DFSa i doszliœmy do wierzcho³ka <I>v</I>. ¯eby obliczyæ <I>Low</I> dla niego to musimy rozpatrzyæ pewne wartoœci dla s¹siaduj¹cych z nim wierzcho³ków <I>w</I>: <I>Low[w]</I> je¿eli wierzcho³ka <I>w</I> jeszcze nie odwiedziliœmy naszym DFSem, <I>D[w]</I> je¿eli wierzcho³ek <I>w</I> ju¿ odwiedziliœmy, ale (!!!) nie przeszliœmy bezpoœrednio z niego w DFSie do <I>v</I> (czyli <I>w</I> nie jest ojcem <I>v</I> w drzewie przeszukiwania w g³¹b). Teraz jedynie bierzemy najmniejsz¹ z powy¿szych wartoœci i z samego <I>D[v]</I> i to w³aœnie ona jest szukan¹ wartoœci¹ <I>Low[v]</I>.<BR>Ta w miarê formalna definicja mo¿e nie byæ do koñca jasna, wiêc ju¿ t³umaczê. Je¿eli od wierzcho³ka <I>v</I> jesteœmy w stanie dojœæ do ju¿ odwiedzonego wierzcho³ka <I>u</I> inn¹ drog¹ ni¿ t¹ któr¹ doszliœmy z <I>u</I> do <I>v</I> w naszym DFSie, to bierzemy pod uwagê wartoœæ <I>D[u]</I>. I najmniejsza z tych wartoœci to w³aœnie <I>Low[v]</I>. Chyba, ¿e z <I>v</I> nie mo¿na dojœæ do ¿adnego odwiedzonego wczeœniej wierzcho³ka, to wtedy <TT>Low[v]=D[v]</TT>.</P><P ALIGN="justify">W praktyce znajdowanie funkcji (tablicy) <I>Low</I> mo¿e wygl¹daæ nastêpuj¹co:<PRE>
  <I>{
  N - liczba wierzcholkow
  D[1..N] - tablica numeracji pre-order
  P[1..N] - tablica poprzednikow (tzn. do wierzch. i-tego przeszlismy z wierzch. P[i])
  Low[1..N] - tablica szukanej funkcji Low
  }</I>

  <B>procedure</B> Visit(v, father: Integer);
  <I>{dodatkowym parametrem jest wierzch., z ktorego przyszlismy}</I>
  <B>begin</B>
    P[v]:=father;
    D[v]:=time;    <I>{przydzielenie numerka w numeracji pre-order}</I>
    Inc(time);
    Low[v]:=D[v];    <I>{Low[v] nie moze byc wieksze niz D[v]}</I>
    <B>for</B> i:=Nieghbour(v) <B>do</B>    <I>{petla po sasiadach wierzch. v}</I>
      <B>if</B> i<>father <B>then</B>  <I>{nie rozwazamy sasiada, z ktorego przyszlismy}</I>
        <B>if</B> D[i]=-1 <B>then</B>    <I>{jesli wierzch. i jest nieodwiedzony}</I>
        <B>begin</B>
          Visit(i,v);      <I>{przechodzimy rekurencyjnie do wierzch. i}</I>
          <B>if</B> Low[v]>Low[i] <B>then</B>   <I>{oraz badamy Low tego wierzcholka}</I>
            Low[v]:=Low[i];
        <B>end else</B>     <I>{jesli wierzch. i byl juz odwiedzony}</I>
          <B>if</B> Low[v]>D[i] <B>then</B>    <I>{badamy jego numer pre-order}</I>
            Low[v]:=D[i];
  <B>end</B>;

  <B>procedure</B> DFS;
  <B>begin</B>
    <B>for</B> i:=1 <B>to</B> N <B>do</B>
      D[i]:=-1;    <I>{oznaczamy wszystkie wierzcholki jako nieodwiedzone}</I>
    time:=1;    <I>{zmienna potrzebna do numeracji}</I>

    <B>for</B> i:=1 <B>to</B> N <B>do</B>
      <B>if</B> D[i]=-1 <B>then</B>    <I>{jesli wierzch. i jest niodwiedzony to ...}</I>
        Visit(i,-1);    <I>{przechodzimy do wierzch. i}</I>
  <B>end</B>;
</PRE></P><HR WIDTH=80%><H3>Punkty artykulacji:</H3><P ALIGN="justify">No. Teraz jak znamy ju¿ funkcjê <I>Low</I> znalezienie punktów artykulacji nie jest ju¿ wielkim problemem. Otó¿ wierzcho³ek <I>v</I> jest punktem artykulacji gdy: je¿eli jest korzeniem w drzewie DFS (<TT>P[v]=-1</TT>), to ma wiêcej ni¿ jednego syna; je¿eli nie jest korzeniem, to dla któregoœ z jego synów <I>w</I> w drzewie DFS spe³niony jest warunek <TT>Low[w]>=D[v]</TT>.<BR>A teraz któtkie wyt³umaczenie (dla zainteresowanych). <I>Low[w]</I> to jest taki "najmniejszy" wierzcho³ek, do którego mo¿na dotrzeæ z <I>w</I> inn¹ drog¹ ni¿ przyszliœmy. Za³o¿yliœmy, ¿e <I>w</I> jest synem <I>v</I> w drzewie/lesie przeszukiwania w g³¹b, czyli to w³aœnie z <I>v</I> przyszliœmy. A skoro <TT>Low[w]>=D[v]</TT> to nie jesteœmy w stanie z <I>w</I> dojœæ do przodków <I>v</I> w drzewie/lesie inn¹ drog¹ ni¿ przez <I>v</I> (bo <I>v</I> ma przecie¿ wiêkszy numer od swoich przodków). Wiêc gdybyœmy usunêli <I>v</I> to rozpspójnili byœmy graf, zatem jest on punktem artykulacji.<BR>To rozwa¿anie jednak nie dotyczy korzenia drzewa/lasu przeszukiwania w g³¹b, bo przecie¿ nie mo¿na przejœæ do jego przodków (skoro ich nie ma), a wcale nie musi byæ punktem artykulacji. Tutaj warto zauwa¿yæ, ¿e je¿eli korzeñ ma kilku synów, to le¿y on na jedynej drodze ³¹cz¹cej tych synów. Gdyby by³o inaczej, to jeden z tych synów by³by potomkiem drugiego, zamiast byæ synem korzenia (trochê zagmatwa³êm, co?). Co za tym idzie usuniêcie korzenia oddzieli³oby od  siebie jego synów i graf uleg³by rozspójnieniu.</P><P ALIGN="justify">Na jedn¹ rzecz chcia³bym zwróciæ uwagê. ¯e drzewo DFS mo¿e byæ w ogólnoœci lasem, czyli mo¿e byæ kilka korzeni. W przypadku grafów nieskierowanych (jakimi siê teraz zajmujemy) jedno drzewo z lasu odpowiada jednej spójnej sk³adowej.</P><P ALIGN="justify">Mo¿e jednak wynikn¹æ jeszcze jeden praktyczny problem. Mianowicie tablica <I>P</I> okreœla nam ojców ka¿dego wierzcho³ka w drzewie DFS, a my potrzebujemy synów. Mo¿na zawsze przet³umaczyæ jedn¹ reprezentacjê drzewa na drug¹, ale to jest zbyt pracoch³onne.<BR>Mo¿emy spojrzeæ na problem odwrotnie: je¿eli dla pewnego wierzcho³ka <I>v</I> o ojcu <I>P[v]</I> (ojciec nie mo¿e byæ korzeniem, czyli <TT>P[P[v]]<>-1</TT>)
      spe³niony jest warunek <TT>Low[v]>=D[P[v]]</TT> to <I>P[v]</I> jest
      punktem artykulacji.<BR>
      Ten problem mo¿na unikn¹æ je¿eli wyznaczanie punktów artykulacji zrobimy
      podczas wykonywania DFSa.
    </P>
    <HR WIDTH=80%>
    <H3>Mosty:</H3>
    <P ALIGN="justify">
      Ze znajdowaniem mostów sprawa jest jeszcze prostsza. Po prostu ka¿dy
      wierzcho³ek <I>v</I> (o ile nie jest korzeniem), który ma <TT>Low[v]=D[v]</TT>
      tworzy ze swoim ojcem (<I>P[v]</I>) most.<BR>
      Tutaj z wyt³umaczeniem bêdzie nieco ³atwiej. Skoro <TT>Low[v]=D[v]</TT> to nie
      mo¿na przejœæ do ¿adnego jego poprzednika w drzewie przeszukiwania w g³¹b (inn¹
      drog¹ ni¿ doszliœmy). Co za tym idzie z ¿adnym poprzednikiem nie le¿y w jednym
      cyklu, w tym tak¿e ze swoim bezpoœrednim poprzednikiem <I>P[v]</I>.
      Zatem krawêdŸ <I>v-P[v]</I> nie le¿y w ¿adnym cyklu, a skoro tak to nie mo¿e
      nale¿eæ do ¿adnej dwuspójnej sk³adowej, wiêc jest mostem.
    </P>
    <P ALIGN="justify">
      Warto zauwa¿yæ, ¿e mostów w grafie mo¿e byæ co najwy¿ej <I>V-1</I>, gdzie
      <I>V</I> jest liczb¹ wierzcho³ków w grafie. Ale to tylko taka praktyczna uwaga
      o niewielkim znaczeniu.
    </P>
    <HR WIDTH=80%>
    <H3>Dwuspójne sk³adowe:</H3>
    <P ALIGN="justify">
      Ze znajdowaniem dwuspójnych sk³adowych ju¿ siê zaczyna pewien problem.
      Nie jest to takie ³atwe jak znajdowanie mostów czy punktów artykulacji.
      Algorytm nale¿y wykonywaæ podczas wykonywania DFSa i obliczania funkcji <I>Low</I>,
      przy u¿yciu pewnej dodatkowej struktury.
    </P>
    <P ALIGN="justify">
      Bardzo przydatn¹ rzecz¹ do znajdowania dwuspójnych sk³adowych bêdzie stos.
      Otó¿ podczas wykonywania DFSa (razem z obliczaniem <I>Low</I>) odk³adamy wszystkie
      napotkane krawêdzie na stos. K³adziemy nie tylko te, które ewidentnie "przeszliœmy"
      (przechodz¹c z wierzcho³ka do wierzcho³ka), ale tak¿e te, które wykorzystaliœmy
      do "podejrzenia" czy jakiœ wierzcho³ek ju¿ zosta³ odwiedzony i zaprowadzi³y
      nas do poprzednika w drzewie/lesie przeszukiwania w g³¹b (czyli do wierzcho³ka
      o mniejszym numerze pre-order).<BR>
      Przypuœæmy, ¿e doszliœmy naszym DFSem do pewnego wierzcho³ka <I>v</I> i jednym
      z jego nieodwiedzonych nastêpników jest <I>w</I>. Zatem przechodzimy rekurencyjnie
      do <I>w</I> (odk³adamy <I>v-w</I> na sotos), z niego te¿ chodzimy sobie dalej
      (odk³adaj¹c ró¿ne inne krawêdzie) i w koñcu rekurencyjnie wrócimy do <I>v</I>
      (standardowa procedura w przypadku DFSa). Je¿eli wtedy siê oka¿e, ¿e
      <TT>Low[w]>=D[v]</TT> to znaczy, ¿e <I>v</I> jest punktem artykulacji
      (no, nie zawsze, ale tutaj akurat nie ma to znaczenia), który oddziela
      dwuspójn¹ sk³adow¹ zawieraj¹c¹ krawêdŸ <I>v-w</I> od pozosta³ej czêœci grafu
      (no, te¿ nie tak do koñca). Objawia siê to tym, ¿e na stosie s¹ wszystkie
      krawêdzie tej sk³adowej, oddzielone od pozosta³ych krawêdzi¹ <I>v-w</I> (która,
      jako ¿e od³o¿ona najwczeœniej, jest najg³êbiej stosu). Wystarczy jedynie zdj¹æ te
      krawêdzie i ju¿.<BR>
      Przed chwil¹ napisa³em, ¿e wierzcho³ek <I>v</I> oddziela nam dwuspójn¹ sk³adow¹
      od reszty grafu, co nie jest prawd¹. W rzeczywistoœci oddziela nam kilka ca³ych
      sk³adowych (w tym tak¿e t¹ zawieraj¹c¹ krawêdŸ <I>v-w</I>)od reszty.
      Na szczêœcie w praktyce nie musimy siê tym przejmowaæ, poniewa¿ pozosta³e sk³adowe
      "obs³u¿ymy" zanim wrócimy do wierzcho³ka <I>v</I> i ich krawêdzie znikn¹ ze stosu.
    </P>
    <P ALIGN="justify">
      Z w³asnego doœwiadczenia wiem, ¿e opis teoretyczny tego algorytmu nie ma szans
      byæ przejrzysty i zrozumia³y. Dopiero po zobaczeniu kodu wszystko siê rozjaœnia.
      Dlatego postanowi³em na poparcie moich pokrêtnych wywodów pokazaæ programik.
      Wynikiem jego dzia³ania jest tablica <I>C[e]</I>, w której zapisane
      s¹ numery dwuspójnych sk³adowych, do których s¹ dane krawêdzie przypisane.
<PRE>
  <I>{
  N - liczba wierzcholkow
  D[1..N] - tablica numeracji pre-order
  Low[1..N] - tablica funkcji Low
  C[krawedzie] - tablicy przynaleznosci krawedzi do dwuspojnych skladowych
  }</I>

  <B>procedure</B> Visit(v, father: Integer);
  <I>{dodatkowym parametrem jest wierzch., z ktorego przyszlismy}</I>
  <B>begin</B>
    D[v]:=time;    <I>{przydzielenie numerka w numeracji pre-order}</I>
    Inc(time);
    Low[v]:=D[v];    <I>{Low[v] nie moze byc wieksze niz D[v]}</I>
    <B>for</B> i:=Nieghbour(v) <B>do</B>    <I>{petla po sasiadach wierzch. v}</I>
      <B>if</B> i<>father <B>then</B>  <I>{nie rozwazamy sasiada, z ktorego przyszlismy}</I>
        <B>if</B> D[i]=-1 <B>then</B>    <I>{jesli wierzch. i jest nieodwiedzony}</I>
        <B>begin</B>
          Put_On_Stack(v<->i);  <I>{odkladamy krawedz, po ktorej przejdziemy na stos}</I>
          Visit(i,v);      <I>{przechodzimy rekurencyjnie do wierzch. i}</I>
          <B>if</B> Low[v]>Low[i] <B>then</B>   <I>{oraz badamy Low tego wierzcholka}</I>
            Low[v]:=Low[i];
          <B>if</B> Low[i]>=D[v] <B>then</B>   <I>{wykryto dwuspojna skladowa}</I>
          <B>begin</B>
            Inc(No);     <I>{rozpatrujemy skladowa o kolejnym numerze}</I>
            <B>repeat</B>
              Get_From_Stack(e);   <I>{zdejmij ze stosu kolejna krawedz skladowej}</I>
              C[e]:=No;      <I>{oznacza, ze krawedz nalezy do skladowej o numerze No}</I>
            <B>until</B> e=v<->i;
          <B>end</B>;
        <B>end else</B>     <I>{jesli wierzch. i byl juz odwiedzony}</I>
        <B>begin</B>
          <B>if</B> D[v]>D[i] <B>then</B>   <I>{jesli i jest poprzednikiem v w drzewie}</I>
            Put_On_Stack(v<->i);  <I>{odkladamy "podgladana" krawedz}</I>
          <B>if</B> Low[v]>D[i] <B>then</B>    <I>{badamy numer pre-order wierzch. i}</I>
            Low[v]:=D[i];
        <B>end</B>;
  <B>end</B>;

  <B>procedure</B> FindConstituent;
  <B>begin</B>
    <B>for</B> i:=1 <B>to</B> N <B>do</B>
      D[i]:=-1;    <I>{oznaczamy wszystkie wierzcholki jako nieodwiedzone}</I>
    time:=1;   <I>{zmienna potrzebna do numeracji pre-order}</I>
    No:=0;     <I>{zmienna potrzebna do numeracji skladowych}</I>

    <B>for</B> i:=1 <B>to</B> N <B>do</B>
      <B>if</B> D[i]=-1 <B>then</B>    <I>{jesli wierzch. i jest nieodwiedzony to ...}</I>
        Visit(i,-1);    <I>{przechodzimy do wierzch. i}</I>
  <B>end</B>;
</PRE>
    </P>
    <HR WIDTH=80%>
    <H3>Z³o¿onoœæ czasowa:</H3>
    <P ALIGN="justify">
      Algorytm znajdowania punktów artykulacji, mostów i dwuspójnych sk³adowych
      sprowadza siê ca³kowicie do wykonania algorytmu DFS (z pewnymi dodatkowymi
      czynnoœciami). Wymaga to kilkukrotnego (ale ograniczonego przez sta³¹)
      przejrzenia ka¿dej krawêdzi, czyli algorytm(y) dzia³a(j¹) w czasie O(E)
      (o ile zosta³a zastosowana sensowna reprezentacja grafu).
    </P>
  </BODY>
</HTML>
